---
/**
 * PremiumEffects - Award-winning animation suite
 *
 * Includes:
 * - Animated counters (stats that count up on scroll)
 * - 3D card tilt effects
 * - Text split reveal animations
 * - Magnetic elements
 * - Image reveal effects
 * - Gradient border animations
 * - Floating parallax elements
 * - Enhanced form interactions
 *
 * Usage: Add this component to your layout, then use data attributes
 * on elements to activate effects.
 *
 * @example
 * <span data-counter="150">0</span>
 * <div data-tilt>Card content</div>
 * <h2 data-text-reveal>Reveal this text</h2>
 * <button data-magnetic>Click me</button>
 * <img data-image-reveal src="..." />
 * <div data-gradient-border>Content</div>
 * <div data-parallax="0.2">Floating element</div>
 * <input data-enhanced-input />
 */
---

<!-- Premium Effects Styles -->
<style is:global>
  /* ===== ANIMATED COUNTER ===== */
  [data-counter] {
    display: inline-block;
    font-variant-numeric: tabular-nums;
  }

  /* ===== 3D CARD TILT ===== */
  [data-tilt] {
    transform-style: preserve-3d;
    transform: perspective(1000px) rotateX(0deg) rotateY(0deg);
    transition: transform 0.1s ease-out;
    will-change: transform;
  }

  [data-tilt] .tilt-inner {
    transform: translateZ(30px);
    transition: transform 0.3s ease-out;
  }

  [data-tilt]:hover .tilt-inner {
    transform: translateZ(50px);
  }

  [data-tilt]::before {
    content: '';
    position: absolute;
    inset: 0;
    background: radial-gradient(
      circle at var(--mouse-x, 50%) var(--mouse-y, 50%),
      rgba(255, 255, 255, 0.1) 0%,
      transparent 50%
    );
    opacity: 0;
    transition: opacity 0.3s ease;
    pointer-events: none;
    border-radius: inherit;
  }

  [data-tilt]:hover::before {
    opacity: 1;
  }

  /* ===== TEXT REVEAL ANIMATIONS ===== */
  [data-text-reveal] {
    overflow: hidden;
  }

  [data-text-reveal] .word {
    display: inline-block;
    overflow: hidden;
    vertical-align: top;
  }

  [data-text-reveal] .word-inner {
    display: inline-block;
    transform: translateY(100%);
    transition: transform 0.6s cubic-bezier(0.16, 1, 0.3, 1);
  }

  [data-text-reveal].revealed .word-inner {
    transform: translateY(0);
  }

  [data-text-reveal] .word:nth-child(1) .word-inner { transition-delay: 0s; }
  [data-text-reveal] .word:nth-child(2) .word-inner { transition-delay: 0.05s; }
  [data-text-reveal] .word:nth-child(3) .word-inner { transition-delay: 0.1s; }
  [data-text-reveal] .word:nth-child(4) .word-inner { transition-delay: 0.15s; }
  [data-text-reveal] .word:nth-child(5) .word-inner { transition-delay: 0.2s; }
  [data-text-reveal] .word:nth-child(6) .word-inner { transition-delay: 0.25s; }
  [data-text-reveal] .word:nth-child(7) .word-inner { transition-delay: 0.3s; }
  [data-text-reveal] .word:nth-child(8) .word-inner { transition-delay: 0.35s; }
  [data-text-reveal] .word:nth-child(9) .word-inner { transition-delay: 0.4s; }
  [data-text-reveal] .word:nth-child(10) .word-inner { transition-delay: 0.45s; }
  [data-text-reveal] .word:nth-child(n+11) .word-inner { transition-delay: 0.5s; }

  /* Character reveal variant */
  [data-char-reveal] .char {
    display: inline-block;
    opacity: 0;
    transform: translateY(50%) rotateX(-45deg);
    transition: all 0.4s cubic-bezier(0.16, 1, 0.3, 1);
  }

  [data-char-reveal].revealed .char {
    opacity: 1;
    transform: translateY(0) rotateX(0);
  }

  /* ===== MAGNETIC ELEMENTS ===== */
  [data-magnetic] {
    display: inline-block;
    transition: transform 0.2s cubic-bezier(0.33, 1, 0.68, 1);
    will-change: transform;
  }

  [data-magnetic-strong] {
    display: inline-block;
    transition: transform 0.15s cubic-bezier(0.33, 1, 0.68, 1);
    will-change: transform;
  }

  /* ===== IMAGE REVEAL ===== */
  [data-image-reveal] {
    position: relative;
    overflow: hidden;
  }

  [data-image-reveal]::after {
    content: '';
    position: absolute;
    inset: 0;
    background: linear-gradient(135deg, var(--neon-pink) 0%, var(--neon-cyan) 100%);
    transform: scaleX(1);
    transform-origin: right;
    transition: transform 0.8s cubic-bezier(0.76, 0, 0.24, 1);
    z-index: 1;
  }

  [data-image-reveal].revealed::after {
    transform: scaleX(0);
  }

  [data-image-reveal] img,
  [data-image-reveal] > * {
    transform: scale(1.2);
    transition: transform 1.2s cubic-bezier(0.16, 1, 0.3, 1);
  }

  [data-image-reveal].revealed img,
  [data-image-reveal].revealed > * {
    transform: scale(1);
  }

  /* Vertical reveal variant */
  [data-image-reveal="vertical"]::after {
    transform: scaleY(1);
    transform-origin: top;
  }

  [data-image-reveal="vertical"].revealed::after {
    transform: scaleY(0);
  }

  /* ===== GRADIENT BORDER ===== */
  [data-gradient-border] {
    position: relative;
    background: var(--dark, #0a0a0f);
    z-index: 0;
  }

  [data-gradient-border]::before {
    content: '';
    position: absolute;
    inset: 0;
    padding: 2px;
    background: linear-gradient(
      var(--gradient-angle, 135deg),
      var(--neon-pink) 0%,
      var(--neon-purple, #bf00ff) 50%,
      var(--neon-cyan) 100%
    );
    -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
    -webkit-mask-composite: xor;
    mask-composite: exclude;
    border-radius: inherit;
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.4s ease;
  }

  [data-gradient-border]:hover::before,
  [data-gradient-border].active::before {
    opacity: 1;
  }

  /* Animated gradient border */
  [data-gradient-border="animated"]::before {
    animation: gradientRotate 3s linear infinite paused;
    opacity: 0.5;
  }

  [data-gradient-border="animated"]:hover::before {
    animation-play-state: running;
    opacity: 1;
  }

  @keyframes gradientRotate {
    0% { --gradient-angle: 0deg; }
    100% { --gradient-angle: 360deg; }
  }

  @property --gradient-angle {
    syntax: '<angle>';
    initial-value: 135deg;
    inherits: false;
  }

  /* Always visible gradient border */
  [data-gradient-border="always"]::before {
    opacity: 0.6;
    animation: gradientRotate 4s linear infinite;
  }

  [data-gradient-border="always"]:hover::before {
    opacity: 1;
  }

  /* ===== PARALLAX FLOAT ===== */
  [data-parallax] {
    will-change: transform;
    transition: transform 0.1s linear;
  }

  /* ===== ENHANCED FORM INPUTS ===== */
  [data-enhanced-input] {
    position: relative;
    transition: all 0.3s ease;
  }

  [data-enhanced-input]:focus {
    outline: none;
    box-shadow:
      0 0 0 2px var(--dark, #0a0a0f),
      0 0 0 4px var(--neon-pink),
      0 0 30px rgba(255, 0, 110, 0.3);
  }

  /* Input wrapper for floating label */
  .input-wrapper {
    position: relative;
  }

  .input-wrapper label {
    position: absolute;
    left: 1rem;
    top: 50%;
    transform: translateY(-50%);
    color: rgba(255, 255, 255, 0.4);
    pointer-events: none;
    transition: all 0.3s cubic-bezier(0.16, 1, 0.3, 1);
    font-size: 0.95rem;
  }

  .input-wrapper input:focus + label,
  .input-wrapper input:not(:placeholder-shown) + label,
  .input-wrapper textarea:focus + label,
  .input-wrapper textarea:not(:placeholder-shown) + label {
    top: 0;
    transform: translateY(-100%) scale(0.85);
    color: var(--neon-cyan);
    background: var(--dark, #0a0a0f);
    padding: 0 0.5rem;
  }

  /* Input glow animation */
  .input-glow {
    position: absolute;
    inset: -2px;
    background: linear-gradient(135deg, var(--neon-pink), var(--neon-cyan));
    border-radius: inherit;
    opacity: 0;
    z-index: -1;
    filter: blur(8px);
    transition: opacity 0.3s ease;
  }

  [data-enhanced-input]:focus ~ .input-glow {
    opacity: 0.5;
  }

  /* ===== SCROLL TRIGGERED FADE ===== */
  [data-scroll-fade] {
    opacity: 0;
    transform: translateY(30px);
    transition: all 0.6s cubic-bezier(0.16, 1, 0.3, 1);
  }

  [data-scroll-fade].visible {
    opacity: 1;
    transform: translateY(0);
  }

  [data-scroll-fade="left"] {
    transform: translateX(-50px);
  }

  [data-scroll-fade="left"].visible {
    transform: translateX(0);
  }

  [data-scroll-fade="right"] {
    transform: translateX(50px);
  }

  [data-scroll-fade="right"].visible {
    transform: translateX(0);
  }

  [data-scroll-fade="scale"] {
    transform: scale(0.9);
  }

  [data-scroll-fade="scale"].visible {
    transform: scale(1);
  }

  /* Stagger delays */
  [data-scroll-fade][data-delay="1"] { transition-delay: 0.1s; }
  [data-scroll-fade][data-delay="2"] { transition-delay: 0.2s; }
  [data-scroll-fade][data-delay="3"] { transition-delay: 0.3s; }
  [data-scroll-fade][data-delay="4"] { transition-delay: 0.4s; }
  [data-scroll-fade][data-delay="5"] { transition-delay: 0.5s; }

  /* ===== HOVER GLOW ===== */
  [data-hover-glow] {
    position: relative;
  }

  [data-hover-glow]::after {
    content: '';
    position: absolute;
    inset: -10px;
    background: radial-gradient(
      circle at center,
      var(--glow-color, rgba(255, 0, 110, 0.4)) 0%,
      transparent 70%
    );
    opacity: 0;
    transition: opacity 0.3s ease;
    pointer-events: none;
    z-index: -1;
    filter: blur(20px);
  }

  [data-hover-glow]:hover::after {
    opacity: 1;
  }

  [data-hover-glow="cyan"]::after {
    --glow-color: rgba(0, 245, 255, 0.4);
  }

  [data-hover-glow="purple"]::after {
    --glow-color: rgba(191, 0, 255, 0.4);
  }

  /* ===== BUTTON RIPPLE ===== */
  [data-ripple] {
    position: relative;
    overflow: hidden;
  }

  [data-ripple] .ripple {
    position: absolute;
    border-radius: 50%;
    background: rgba(255, 255, 255, 0.3);
    transform: scale(0);
    animation: rippleEffect 0.6s ease-out forwards;
    pointer-events: none;
  }

  @keyframes rippleEffect {
    to {
      transform: scale(4);
      opacity: 0;
    }
  }

  /* ===== LINE DRAWING ===== */
  [data-line-draw] {
    stroke-dasharray: var(--line-length, 1000);
    stroke-dashoffset: var(--line-length, 1000);
    transition: stroke-dashoffset 1.5s cubic-bezier(0.16, 1, 0.3, 1);
  }

  [data-line-draw].drawn {
    stroke-dashoffset: 0;
  }

  /* ===== REDUCED MOTION ===== */
  @media (prefers-reduced-motion: reduce) {
    [data-tilt],
    [data-magnetic],
    [data-magnetic-strong],
    [data-parallax] {
      transform: none !important;
      transition: none !important;
    }

    [data-text-reveal] .word-inner,
    [data-char-reveal] .char {
      transform: none !important;
      opacity: 1 !important;
      transition: none !important;
    }

    [data-image-reveal]::after {
      display: none;
    }

    [data-image-reveal] img,
    [data-image-reveal] > * {
      transform: none !important;
    }

    [data-scroll-fade] {
      opacity: 1 !important;
      transform: none !important;
      transition: none !important;
    }

    [data-gradient-border="animated"]::before {
      animation: none;
    }
  }
</style>

<script>
  // Check for reduced motion preference
  const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
  const isTouchDevice = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);

  if (!prefersReducedMotion) {
    // ===== ANIMATED COUNTERS =====
    const counters = document.querySelectorAll('[data-counter]');

    const counterObserver = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          const el = entry.target as HTMLElement;
          const target = parseInt(el.dataset.counter || '0', 10);
          const duration = parseInt(el.dataset.counterDuration || '2000', 10);
          const suffix = el.dataset.counterSuffix || '';
          const prefix = el.dataset.counterPrefix || '';

          animateCounter(el, target, duration, prefix, suffix);
          counterObserver.unobserve(el);
        }
      });
    }, { threshold: 0.5 });

    counters.forEach(counter => counterObserver.observe(counter));

    function animateCounter(el: HTMLElement, target: number, duration: number, prefix: string, suffix: string) {
      const start = 0;
      const startTime = performance.now();

      function update(currentTime: number) {
        const elapsed = currentTime - startTime;
        const progress = Math.min(elapsed / duration, 1);

        // Ease out cubic
        const eased = 1 - Math.pow(1 - progress, 3);
        const current = Math.round(start + (target - start) * eased);

        el.textContent = `${prefix}${current.toLocaleString()}${suffix}`;

        if (progress < 1) {
          requestAnimationFrame(update);
        }
      }

      requestAnimationFrame(update);
    }

    // ===== 3D CARD TILT =====
    if (!isTouchDevice) {
      const tiltCards = document.querySelectorAll('[data-tilt]');

      tiltCards.forEach(card => {
        const el = card as HTMLElement;
        const intensity = parseFloat(el.dataset.tiltIntensity || '10');

        el.addEventListener('mousemove', (e: MouseEvent) => {
          const rect = el.getBoundingClientRect();
          const x = e.clientX - rect.left;
          const y = e.clientY - rect.top;
          const centerX = rect.width / 2;
          const centerY = rect.height / 2;

          const rotateX = ((y - centerY) / centerY) * -intensity;
          const rotateY = ((x - centerX) / centerX) * intensity;

          el.style.transform = `perspective(1000px) rotateX(${rotateX}deg) rotateY(${rotateY}deg)`;
          el.style.setProperty('--mouse-x', `${(x / rect.width) * 100}%`);
          el.style.setProperty('--mouse-y', `${(y / rect.height) * 100}%`);
        });

        el.addEventListener('mouseleave', () => {
          el.style.transform = 'perspective(1000px) rotateX(0deg) rotateY(0deg)';
        });
      });
    }

    // ===== TEXT REVEAL =====
    const textReveals = document.querySelectorAll('[data-text-reveal]');

    textReveals.forEach(el => {
      const text = el.textContent || '';
      const words = text.split(' ');

      el.innerHTML = words.map(word =>
        `<span class="word"><span class="word-inner">${word}</span></span>`
      ).join(' ');
    });

    const charReveals = document.querySelectorAll('[data-char-reveal]');

    charReveals.forEach(el => {
      const text = el.textContent || '';
      const chars = text.split('');

      el.innerHTML = chars.map((char, i) =>
        `<span class="char" style="transition-delay: ${i * 0.03}s">${char === ' ' ? '&nbsp;' : char}</span>`
      ).join('');
    });

    const textRevealObserver = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          entry.target.classList.add('revealed');
        }
      });
    }, { threshold: 0.2 });

    textReveals.forEach(el => textRevealObserver.observe(el));
    charReveals.forEach(el => textRevealObserver.observe(el));

    // ===== MAGNETIC ELEMENTS =====
    if (!isTouchDevice) {
      const magneticElements = document.querySelectorAll('[data-magnetic], [data-magnetic-strong]');

      magneticElements.forEach(el => {
        const element = el as HTMLElement;
        const isStrong = element.hasAttribute('data-magnetic-strong');
        const strength = isStrong ? 0.4 : 0.25;

        element.addEventListener('mousemove', (e: MouseEvent) => {
          const rect = element.getBoundingClientRect();
          const x = e.clientX - rect.left - rect.width / 2;
          const y = e.clientY - rect.top - rect.height / 2;

          element.style.transform = `translate(${x * strength}px, ${y * strength}px)`;
        });

        element.addEventListener('mouseleave', () => {
          element.style.transform = 'translate(0, 0)';
        });
      });
    }

    // ===== IMAGE REVEAL =====
    const imageReveals = document.querySelectorAll('[data-image-reveal]');

    const imageRevealObserver = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          entry.target.classList.add('revealed');
          imageRevealObserver.unobserve(entry.target);
        }
      });
    }, { threshold: 0.3 });

    imageReveals.forEach(el => imageRevealObserver.observe(el));

    // ===== PARALLAX =====
    const parallaxElements = document.querySelectorAll('[data-parallax]');
    let ticking = false;

    function updateParallax() {
      parallaxElements.forEach(el => {
        const element = el as HTMLElement;
        const speed = parseFloat(element.dataset.parallax || '0.1');
        const rect = element.getBoundingClientRect();
        const scrolled = window.scrollY;
        const elementTop = rect.top + scrolled;
        const offset = (scrolled - elementTop + window.innerHeight) * speed;

        element.style.transform = `translateY(${offset}px)`;
      });
      ticking = false;
    }

    window.addEventListener('scroll', () => {
      if (!ticking) {
        requestAnimationFrame(updateParallax);
        ticking = true;
      }
    });

    // ===== SCROLL FADE =====
    const scrollFadeElements = document.querySelectorAll('[data-scroll-fade]');

    const scrollFadeObserver = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          entry.target.classList.add('visible');
        }
      });
    }, { threshold: 0.1, rootMargin: '-50px' });

    scrollFadeElements.forEach(el => scrollFadeObserver.observe(el));

    // ===== BUTTON RIPPLE =====
    const rippleButtons = document.querySelectorAll('[data-ripple]');

    rippleButtons.forEach(btn => {
      btn.addEventListener('click', function(e: Event) {
        const event = e as MouseEvent;
        const button = event.currentTarget as HTMLElement;
        const rect = button.getBoundingClientRect();
        const size = Math.max(rect.width, rect.height);
        const x = event.clientX - rect.left - size / 2;
        const y = event.clientY - rect.top - size / 2;

        const ripple = document.createElement('span');
        ripple.className = 'ripple';
        ripple.style.width = ripple.style.height = `${size}px`;
        ripple.style.left = `${x}px`;
        ripple.style.top = `${y}px`;

        button.appendChild(ripple);

        ripple.addEventListener('animationend', () => {
          ripple.remove();
        });
      });
    });

    // ===== LINE DRAWING =====
    const lineDrawElements = document.querySelectorAll('[data-line-draw]');

    lineDrawElements.forEach(el => {
      const path = el as SVGPathElement;
      const length = path.getTotalLength();
      path.style.setProperty('--line-length', String(length));
    });

    const lineDrawObserver = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          entry.target.classList.add('drawn');
        }
      });
    }, { threshold: 0.5 });

    lineDrawElements.forEach(el => lineDrawObserver.observe(el));
  }
</script>
